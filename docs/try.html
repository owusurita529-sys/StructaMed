<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Try StructaMed</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    .try-grid {
      display: grid;
      gap: 16px;
    }
    .control-grid {
      display: grid;
      gap: 12px;
    }
    .control-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }
    label {
      font-weight: 600;
      color: var(--accent-3);
    }
    textarea,
    select {
      width: 100%;
      font-family: var(--mono-font);
      font-size: 0.95rem;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(38, 70, 83, 0.2);
      background: #fff;
      color: var(--ink);
    }
    textarea {
      min-height: 220px;
      line-height: 1.45;
    }
    .inline-field {
      min-width: 180px;
      flex: 1;
    }
    .checkbox {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: var(--accent-3);
    }
    .checkbox input {
      width: 16px;
      height: 16px;
    }
    .result {
      white-space: pre-wrap;
      min-height: 220px;
      margin: 0;
    }
    .output-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }
    .status {
      margin: 0;
      font-family: var(--mono-font);
      color: var(--accent-3);
    }
    .status.error {
      color: #a73535;
    }
    .status.ok {
      color: var(--accent-2);
    }
    .clean-summary {
      margin: 0;
      font-family: var(--mono-font);
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header class="site-header">
    <nav class="nav">
      <a class="brand" href="index.html">
        <img src="assets/logo.svg" alt="StructaMed logo" />
        <span>StructaMed</span>
      </a>
      <div class="nav-links">
        <a href="index.html">Home</a>
        <a href="docs.html">Docs</a>
        <a href="pricing.html">Pricing</a>
        <a href="download.html">Download</a>
        <a href="try.html" class="active">Try it</a>
        <a href="https://github.com/owusurita529-sys/StructaMed" target="_blank" rel="noopener noreferrer">GitHub</a>
      </div>
    </nav>
  </header>

  <main>
    <section class="section narrow">
      <h1>Try StructaMed in your browser</h1>
      <p class="lead">Paste a messy clinical note, choose a template/output format, and convert it using the same library pipeline as the CLI.</p>

      <div class="panel-card try-grid">
        <div class="control-grid">
          <label for="note-input">Input note</label>
          <textarea id="note-input">CC - chest pain
HPI: started after exercise
PMH: HTN, asthma
Assessment: likely MSK strain
Plan: NSAIDs, follow-up</textarea>
          <div class="control-row">
            <button id="demo-messy-soap-btn" class="btn ghost" type="button">Demo: messy SOAP</button>
            <button id="demo-clean-soap-btn" class="btn ghost" type="button">Demo: clean SOAP</button>
            <button id="demo-discharge-btn" class="btn ghost" type="button">Demo: discharge</button>
          </div>
        </div>

        <div class="control-row">
          <div class="inline-field">
            <label for="template-select">Template</label>
            <select id="template-select">
              <option value="soap">soap</option>
              <option value="hp">hp</option>
              <option value="discharge">discharge</option>
            </select>
          </div>
          <div class="inline-field">
            <label for="output-select">Output format</label>
            <select id="output-select">
              <option value="markdown">markdown</option>
              <option value="json">json</option>
              <option value="csv">csv</option>
            </select>
          </div>
          <label class="checkbox" for="strict-check">
            <input id="strict-check" type="checkbox" />
            Strict validation
          </label>
          <label class="checkbox" for="autoclean-check">
            <input id="autoclean-check" type="checkbox" />
            Auto-clean duplicates
          </label>
        </div>

        <div class="control-row">
          <button id="convert-btn" class="btn primary" type="button">Convert</button>
          <button id="validate-btn" class="btn ghost" type="button">Validate</button>
          <button id="preview-btn" class="btn ghost" type="button">Preview Sections</button>
          <button id="clear-btn" class="btn ghost" type="button">Clear</button>
          <button id="copy-convert-btn" class="btn ghost" type="button">Copy Converted</button>
          <button id="copy-validation-btn" class="btn ghost" type="button">Copy Validation</button>
          <button id="download-convert-btn" class="btn ghost" type="button">Download Converted</button>
          <button id="download-validation-btn" class="btn ghost" type="button">Download Validation</button>
          <p id="status" class="status">WASM loading...</p>
        </div>

        <div class="output-grid">
          <div class="control-grid">
            <p id="clean-summary" class="clean-summary"></p>
            <label for="output-panel">Converted Output</label>
            <pre id="output-panel" class="code-block result"></pre>
          </div>
          <div class="control-grid">
            <label for="validation-panel">Validation Output</label>
            <pre id="validation-panel" class="code-block result"></pre>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer class="footer">
    <p>For demo use only. Synthetic data only.</p>
  </footer>

  <script type="module">
    import init, { convert, normalize, normalize_with_stats, preview_sections, validate } from "./pkg/clinote_wasm.js";

    const noteInput = document.getElementById("note-input");
    const templateSelect = document.getElementById("template-select");
    const outputSelect = document.getElementById("output-select");
    const strictCheck = document.getElementById("strict-check");
    const autocleanCheck = document.getElementById("autoclean-check");
    const demoMessySoapBtn = document.getElementById("demo-messy-soap-btn");
    const demoCleanSoapBtn = document.getElementById("demo-clean-soap-btn");
    const demoDischargeBtn = document.getElementById("demo-discharge-btn");
    const convertBtn = document.getElementById("convert-btn");
    const validateBtn = document.getElementById("validate-btn");
    const previewBtn = document.getElementById("preview-btn");
    const clearBtn = document.getElementById("clear-btn");
    const copyConvertBtn = document.getElementById("copy-convert-btn");
    const copyValidationBtn = document.getElementById("copy-validation-btn");
    const downloadConvertBtn = document.getElementById("download-convert-btn");
    const downloadValidationBtn = document.getElementById("download-validation-btn");
    const cleanSummary = document.getElementById("clean-summary");
    const outputPanel = document.getElementById("output-panel");
    const validationPanel = document.getElementById("validation-panel");
    const status = document.getElementById("status");

    let wasmReady = false;
    let wasmLoading = null;
    let lastValidationPayload = null;
    const DEMO_NOTES = {
      messySoap: {
        template: "soap",
        text: `Pt: John D. 45y M
CC headache x3 days
HPI: started after night shift, photophobia, nausea
PMH: HTN
Vitals: BP 168/96 HR 92 T 36.9
Exam: neuro intact, mild photophobia
A: migraine vs tension; uncontrolled HTN
P: NSAID + antiemetic; restart amlodipine; f/u 1 week`
      },
      cleanSoap: {
        template: "soap",
        text: `Subjective:
Headache x3 days with nausea and photophobia. No focal weakness.

Objective:
BP 168/96, HR 92, Temp 36.9C. Neuro exam intact, mild photophobia.

Assessment:
Migraine vs tension headache. Hypertension not controlled.

Plan:
NSAID plus antiemetic, restart amlodipine, follow-up in 1 week.`
      },
      discharge: {
        template: "discharge",
        text: `Admission Dx: Migraine headache.
Discharge Dx: Migraine headache improved.
Hospital Course: Treated with antiemetic and NSAID; symptoms improved.
Medications: Ibuprofen PRN, amlodipine daily.
Follow-up: Primary care in 1 week.
Disposition: Home in stable condition.
Instructions: Return for worsening headache, neurologic deficits, or persistent vomiting.`
      }
    };

    function setStatus(text, kind = "") {
      status.textContent = text;
      status.classList.remove("ok", "error");
      if (kind) status.classList.add(kind);
    }

    function formatError(err) {
      if (typeof err === "string") return err;
      if (err && typeof err.message === "string") return err.message;
      return String(err);
    }

    async function ensureWasm() {
      if (wasmReady) return;
      if (!wasmLoading) {
        wasmLoading = init(new URL("./pkg/clinote_wasm_bg.wasm", import.meta.url));
      }
      await wasmLoading;
      wasmReady = true;
      setStatus("WASM ready", "ok");
    }

    async function runConvert() {
      let validationPayload = null;
      try {
        setStatus("Converting...");
        await ensureWasm();
        const prepared = prepareInputForWeb();
        validationPayload = runValidation(prepared.workingText);
        const result = convert(
          prepared.workingText,
          templateSelect.value,
          outputSelect.value,
          strictCheck.checked
        );
        outputPanel.textContent = result || "(no output)";
        setStatus("Conversion complete", "ok");
      } catch (err) {
        const strictFailed = strictCheck.checked && validationPayload && validationPayload.ok === false;
        if (strictFailed) {
          outputPanel.textContent = `Strict validation failed. Turn off Strict or add Subjective/Objective headings.\n\n${formatError(err)}`;
        } else {
          outputPanel.textContent = `Error: ${formatError(err)}`;
        }
        setStatus("Conversion failed", "error");
      }
    }

    function groupWarningsBySection(warnings) {
      const groups = new Map();
      for (const warning of warnings) {
        const match = warning.match(/section '([^']+)'/i);
        const key = match ? match[1] : "General";
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(warning);
      }
      return groups;
    }

    function renderValidation(payload) {
      lastValidationPayload = payload;
      const templateLabel = String(payload.template || templateSelect.value || "").toUpperCase();
      const lines = [`Validation (${templateLabel}, strict=${strictCheck.checked})`];
      const notes = Array.isArray(payload.notes) ? payload.notes : [];
      let errorCount = 0;
      let warningCount = 0;
      let infoCount = 0;
      let hasAssessmentPlanTooShortWarning = false;

      if (notes.length === 0) {
        lines.push("No notes parsed.");
      }

      for (const note of notes) {
        errorCount += Array.isArray(note.errors) ? note.errors.length : 0;
        warningCount += Array.isArray(note.warnings) ? note.warnings.length : 0;
        infoCount += Array.isArray(note.info) ? note.info.length : 0;
      }

      lines.push(`Summary: Errors=${errorCount} Warnings=${warningCount} Info=${infoCount}`);
      lines.push("");

      for (const note of notes) {
        lines.push(`Note ${note.note_index}:`);
        const errors = Array.isArray(note.errors) ? note.errors : [];
        const warnings = Array.isArray(note.warnings) ? note.warnings : [];
        const info = Array.isArray(note.info) ? note.info : [];

        if (
          warnings.some((msg) =>
            /Section '(Assessment|Plan)' is empty or too short/i.test(String(msg))
          )
        ) {
          hasAssessmentPlanTooShortWarning = true;
        }

        if (!errors.length && !warnings.length && !info.length) {
          lines.push("  ✅ No issues");
        }

        for (const msg of errors) lines.push(`  ❌ ${msg}`);

        const warningGroups = groupWarningsBySection(warnings);
        if (warningGroups.size) {
          for (const [section, messages] of warningGroups.entries()) {
            if (section === "General") {
              for (const msg of messages) lines.push(`  ⚠️ ${msg}`);
            } else {
              lines.push(`  ⚠️ ${section}:`);
              for (const msg of messages) {
                lines.push(`    - ${msg}`);
              }
            }
          }
        }

        for (const msg of info) lines.push(`  ℹ️ ${msg}`);
        lines.push("");
      }

      if (!payload.ok) {
        lines.push("");
        lines.push("Result: FAILED");
      } else {
        lines.push("");
        lines.push("Result: OK");
      }

      if (hasAssessmentPlanTooShortWarning) {
        lines.push("Tip: Auto-clean can extract A:/P: lines into Assessment/Plan.");
      }

      validationPanel.textContent = lines.join("\n");
    }

    function runValidation(sourceText = noteInput.value) {
      const payload = validate(sourceText, templateSelect.value, strictCheck.checked);
      renderValidation(payload);
      return payload;
    }

    function countSectionsFromPreview(text) {
      return text
        .split("\n")
        .filter((line) => line.trim().startsWith("- ") && line.includes(":"))
        .length;
    }

    function countSectionsFromNormalized(text) {
      return text
        .split("\n")
        .filter((line) => /^[A-Za-z][A-Za-z0-9 &/-]*:\s*$/.test(line.trim()))
        .length;
    }

    function prepareInputForWeb() {
      const original = noteInput.value;
      if (!autocleanCheck.checked) {
        cleanSummary.textContent = "";
        return { workingText: original };
      }

      const result = normalize_with_stats(original, templateSelect.value);
      const normalized = String(result.normalized || normalize(original, templateSelect.value));
      cleanSummary.textContent =
        `Auto-clean: removed_empty_sections=${result.removed_empty_sections || 0}, ` +
        `merged_duplicates=${result.merged_duplicates || 0}, ` +
        `extracted_subjective_lines=${result.extracted_subjective_lines || 0}, ` +
        `extracted_objective_lines=${result.extracted_objective_lines || 0}`;
      return { workingText: normalized };
    }

    async function runValidateOnly() {
      try {
        setStatus("Validating...");
        await ensureWasm();
        const prepared = prepareInputForWeb();
        runValidation(prepared.workingText);
        setStatus("Validation complete", "ok");
      } catch (err) {
        validationPanel.textContent = `Error: ${formatError(err)}`;
        setStatus("Validation failed", "error");
      }
    }

    async function runPreview() {
      try {
        setStatus("Generating preview...");
        await ensureWasm();
        const result = preview_sections(noteInput.value, templateSelect.value);
        outputPanel.textContent = typeof result === "string" ? result : JSON.stringify(result, null, 2);
        setStatus("Preview complete", "ok");
      } catch (err) {
        outputPanel.textContent = `Error: ${formatError(err)}`;
        setStatus("Preview failed", "error");
      }
    }

    function runClear() {
      const hasInput = noteInput.value.trim().length > 0;
      const hasOutput = outputPanel.textContent.trim().length > 0;
      const hasValidation = validationPanel.textContent.trim().length > 0;
      if ((hasInput || hasOutput || hasValidation) && !confirm("Clear input and output?")) {
        return;
      }

      noteInput.value = "";
      outputPanel.textContent = "";
      validationPanel.textContent = "";
      cleanSummary.textContent = "";
      templateSelect.value = "soap";
      outputSelect.value = "markdown";
      strictCheck.checked = false;
      autocleanCheck.checked = false;
      lastValidationPayload = null;
      status.textContent = "";
      status.classList.remove("ok", "error");
    }

    function loadDemo(demo) {
      noteInput.value = demo.text;
      templateSelect.value = demo.template;
      outputSelect.value = "markdown";
      strictCheck.checked = true;
      autocleanCheck.checked = true;
      outputPanel.textContent = "";
      validationPanel.textContent = "";
      cleanSummary.textContent = "";
      lastValidationPayload = null;
      setStatus("Demo loaded", "ok");
    }

    async function copyText(text, targetLabel) {
      if (!text) {
        setStatus(`Nothing to copy from ${targetLabel}`, "error");
        return;
      }
      try {
        await navigator.clipboard.writeText(text);
        setStatus(`Copied ${targetLabel}`, "ok");
      } catch (err) {
        setStatus(`Copy failed: ${formatError(err)}`, "error");
      }
    }

    function downloadTextFile(filename, text, mimeType) {
      if (!text) {
        setStatus(`Nothing to download for ${filename}`, "error");
        return;
      }
      const blob = new Blob([text], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      anchor.href = url;
      anchor.download = filename;
      document.body.appendChild(anchor);
      anchor.click();
      anchor.remove();
      URL.revokeObjectURL(url);
      setStatus(`Downloaded ${filename}`, "ok");
    }

    function runDownloadConverted() {
      const outputType = outputSelect.value;
      const extension = outputType === "json" ? "json" : outputType === "csv" ? "csv" : "md";
      const mimeType = outputType === "json"
        ? "application/json"
        : outputType === "csv"
          ? "text/csv"
          : "text/markdown";
      downloadTextFile(`structamed-converted.${extension}`, outputPanel.textContent, mimeType);
    }

    function runDownloadValidation() {
      if (!lastValidationPayload) {
        setStatus("Run validation first to download validation JSON", "error");
        return;
      }
      const jsonText = JSON.stringify(lastValidationPayload, null, 2);
      downloadTextFile("structamed-validation.json", jsonText, "application/json");
    }

    convertBtn.addEventListener("click", runConvert);
    validateBtn.addEventListener("click", runValidateOnly);
    previewBtn.addEventListener("click", runPreview);
    clearBtn.addEventListener("click", runClear);
    copyConvertBtn.addEventListener("click", () => copyText(outputPanel.textContent, "converted output"));
    copyValidationBtn.addEventListener("click", () => copyText(validationPanel.textContent, "validation output"));
    downloadConvertBtn.addEventListener("click", runDownloadConverted);
    downloadValidationBtn.addEventListener("click", runDownloadValidation);
    demoMessySoapBtn.addEventListener("click", () => loadDemo(DEMO_NOTES.messySoap));
    demoCleanSoapBtn.addEventListener("click", () => loadDemo(DEMO_NOTES.cleanSoap));
    demoDischargeBtn.addEventListener("click", () => loadDemo(DEMO_NOTES.discharge));

    ensureWasm().catch((err) => {
      setStatus(`WASM load failed: ${formatError(err)}`, "error");
    });
  </script>
</body>
</html>
